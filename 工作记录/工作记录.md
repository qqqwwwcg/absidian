# Git

①云端建立新的远程分支 本地建立与git的关联分支 本地分支开发，开发后 push到对应的同名远程分支

②本地建立分支，开发后 push到远程 ide会发布创建同名远程分支

③git pull origin develop 拉取最近代码，merge到本地分支 再推送到远程分支

④开发完成后 提merge请求，合并远程分支到develop

# Code Review

①注意单词拼写（rust spell插件）、格式（rustfmt插件）、中文符号、命名达意

②注释：清理测试代码、算法加参考链接

③实现：重视warning、代码实现精简、代码可见性(pub)、none/null等情况的保护、内存释放

# 8.22~8.31 框选Object调研
![](https://images-1318884142.cos.ap-guangzhou.myqcloud.com/images/202306232100536.png)

## 任务描述

### Overview

针对框选，调研斜框与AABB的快速剔除，并后续继续根据BVH判断intersect情况，确定被框选中的物体的ID

包括被遮挡的物体，也要被选中

要做到足够精确，透视剔除后再和mesh求交

### Todo

只需要mesh的ID，不用具体选中的交点，法线等额外信息

## 算法调研

### 碰撞检测手段

#### Framebuffer Picker

只能拾取被渲染的物体，无法拾取被遮挡物体

#### 映射屏幕/NDC

对mesh建立包围盒，将包围盒顶点映射到NDC/屏幕空间，与框选范围进行比较

**不可取**，只能判断BV的8个顶点都在视锥体内部的情况；

8个顶点都在视锥体外部，无法判断是否out（8个顶点都在视锥体外部，但是相交）

![image-20220924172211141.png](https://images-1318884142.cos.ap-guangzhou.myqcloud.com/images/202306232101562.png)


#### 判断顶点和平面的内外关系

①检测包围盒8个顶点

判断point和plane的位置关系

 plane:ax+by+cz=d    //tips：a,b,c已经单位化  
 pointP:x,y,z  
 计算点到平面的距离d'  
 d'<0    点在平面的背面（法向朝向相反侧）  
 d'=0    点在平面上  
 d'>0    点在平面的正面（法向朝向侧）  
 d'= (x,y,z) dot (a,b,c).normaliz-d

对视锥体的6个平面进行检测

- 如果检测到8个点都在**某个平面**的背面，out
    
- 如果检测到8个点在**所有平面**的正面，in
    
- else 相交
    

②仅检测离两个顶点

![image-20220924174239948.png](https://images-1318884142.cos.ap-guangzhou.myqcloud.com/images/202306232101547.png)


PQ是最接近normal的向量

P在平面的正面，则8个顶点都在平面的正面

Q在平面的背面，则8个顶点都在平面的背面

else，部分顶点在正面、部分在背面

对视锥体的6个平面进行检测

- 如果检测到8个点都在**某个平面**的背面，out
    
- 如果检测到8个点在**所有平面**的正面，in
    
- else 相交
    

③寻找N、P点

算法思想：如果两个向量是相近的，那么他们在各个轴上的投影也是相近的

将视锥体平面n投影到坐标系上（视锥体还原到世界坐标系），nx=x,ny=y,nz=z

由于AABB与坐标轴对齐，此处寻点可简化如下：

 if(nx>0)    p=AABB.x.max; n=AABB.x.min  
 ​  
 else 相反  
 ​  
 if(ny>0)  
 ​  
 if(nz>0)

AABB**顶点**上的x值，只有xmin、xmax两个值；如果nx>0，则pq在x轴方向的朝向被确定

AABB可以通过三次比较来确定N、P点；

④红色长条的8个点既没有同时在某个平面的外侧(out)，8个顶点也不全在所有平面的内测

**A、B**在上个环节的碰撞检测中，都被视为intersect，但是A情况是false positive

**false positive**：会被判断为相交。but Out

![image-20221003160204195.png](https://images-1318884142.cos.ap-guangzhou.myqcloud.com/images/202306232101893.png)


反向判断视锥体的顶点是否在BV内，若都不在：out，else：相交（包含极端情况，视锥体在BV内测）

==踩坑记录==：AABB由于轴对齐特征，直接判断视锥体的顶点P是否落在AABB的区间内

 min.x<point.x<max.x && min.y<point.y<max.y && min.z<point.z<max.z   \\点在AABB内  
 else 点在AABB外

A的八个顶点都在B外，B的顶点都在A为，并不能说明是outside，可能出现穿插

==正确解法==：通过第一轮检测，得到的结果类似于将AABB投影到视锥体上来检测，需要再将视锥体投影到AABB上检测，参考SAT

此时相当于根据AABB的分离轴来对视锥体和AABB进行分离，并且由于AABB的轴对齐特性，分离轴即为x、y、z轴方向，AABB的投影也通过min、和max来表示；只需要对视锥体建立一个frsurum_bounding

 fn intesect(&self, box:Box3)->IntersectResult{  
     //check intersect false positive:box intersect frusutm,but outside  
     let check_false_positive=||{  
         //box2 is AABB  
         if self.bounding.min.x > box2.max.x || box2.min.x > self.bounding.max.x{  
             ture  
         }else if self.bounding.min.y > box2.max.y || box2.min.y > self.bounding.max.y{  
             true  
         }else if self.bounding.min.z > box2.max.z || box2.min.z > self.bounding.max.z{  
             true  
         }else{  
             false  
         }  
     }  
       
     match self.frustum.intersect(box){  
         Inside=>Inside,  
         Outside=>Outside,  
         Intersect=>{  
             if check_false_positive(){  
                 Outsied  
             }else{  
                 Intersect  
             }  
         }  
     }  
 }

[Inigo Quilez :: computer graphics, mathematics, shaders, fractals, demoscene and more (iquilezles.org)](https://iquilezles.org/articles/frustumcorrect/)

#### Separating Axis Theorem（SAT）

##### 算法思想

SAT的对象必须要是==凸包==，凸包的内角小于180°，如果两个凸包不相交的话，那么必定存在一个分离轴，使得A、B在轴上的投影无重叠部分

穷举不可取，通常两个shape的边上中垂线为分离轴进行检测

ps：对于矩形的对边平行，分离轴数量= 4 / 2

只要找到存在一条分离轴，即可return false；因此，对于不相交的，较快，如果相交的话，必须遍历完所有分离轴

##### 算法流程

**枚举分离轴**

**计算投影**

判断是否存在一个分离轴使得两个shape的投影，不重叠
```
fn sat_collision_detection(shape1: &Vec<(f32, f32)>, shape2: &Vec<(f32, f32)>) -> bool {  
     let mut axes = Vec::new();  
     axes.extend(get_axes(shape1));  
     axes.extend(get_axes(shape2));  
 ​  
     for axis in axes.iter() {  
         let (mut min1, mut max1) = project(shape1, axis);  
         let (mut min2, mut max2) = project(shape2, axis);  
 ​  
         if max1 < min2 || max2 < min1 {  
             return false;  
         }  
     }  
 ​  
     true  
 }  
 ​  
 fn get_axes(shape: &Vec<(f32, f32)>) -> Vec<(f32, f32)> {  
     let mut axes = Vec::new();  
 ​  
     for i in 0..shape.len() {  
         let j = (i + 1) % shape.len();  
         let edge = (shape[j].0 - shape[i].0, shape[j].1 - shape[i].1);  
         let normal = (-edge.1, edge.0);  
         axes.push(normal);  
     }  
 ​  
     axes  
 }  
 ​  
 fn project(shape: &Vec<(f32, f32)>, axis: &(f32, f32)) -> (f32, f32) {  
     let mut min = dot_product(shape[0], *axis);  
     let mut max = min;  
 ​  
     for point in shape.iter().skip(1) {  
         let projection = dot_product(*point, *axis);  
         if projection < min {  
             min = projection;  
         } else if projection > max {  
             max = projection;  
         }  
     }  
 ​  
     (min, max)  
 }  
 ​  
 fn dot_product(point: (f32, f32), axis: (f32, f32)) -> f32 {  
     point.0 * axis.0 + point.1 * axis.1  
 }```  
 ​  
 This is an implementation of the Separating Axis Theorem (SAT) collision detection algorithm in Rust. The `sat_collision_detection` function takes two shapes represented as vectors of points and returns `true` if they are colliding and `false` otherwise. The `get_axes` function calculates the axes to project the shapes onto, and the `project` function projects a shape onto an axis. The `dot_product` function calculates the dot product of two vectors.
```
 

##### 参考链接

[More (Robust) Frustum Culling | Bruno Opsenica's Blog (bruop.github.io)](https://bruop.github.io/improved_frustum_culling/)

#### GJK

##### 前置概念

**Minkowski Sum**：

A + B = {a + b |a∈A，b∈B}

A中的所有点加到B中的所有点上{得到的是另外一个更大更复杂的形状}

另一种形式：A – B = {a – b |a∈A，b∈B} = {a+(**-b**)}

先将B过原点对称，得到-B；再将A与-B相加

若A，B为两个==凸包==，那么A+B也为凸包，且A+B的顶点来自于A顶点+B顶点；（ps:也有一部分A顶点+B顶点的结果在A+B凸包的内部）

**Simplex**

定义：k维空间的多胞形，且这个多胞形为k+1个顶点组成的凸包

![image-20220830215602861.png](https://images-1318884142.cos.ap-guangzhou.myqcloud.com/images/202306232103574.png)


##### 算法原理

GJK的算法思想就来源于A-B，**1、**A与B之间的距离 等价于 **2、**Minkowski Sum（A-B）到原点的距离

![image-20220830221522067.png](https://images-1318884142.cos.ap-guangzhou.myqcloud.com/images/202306232103261.png)


如果A-B的结果中包含原点，那么说明肯定 存在一个点对，a∈A，b∈B；使得a=b，a-b=（0，0）

![image-20220830165612453.png](https://images-1318884142.cos.ap-guangzhou.myqcloud.com/images/202306232103337.png)


GJK的伟大之处在于，对**Minkowski Sum**的简化，没有占据物理空间来创建维护，仅仅是概念上的**Minkowski Sum**

两个凸包进行**Minkowski Sum**的结果仍是一个凸包，可以用两个凸包的顶点组合来囊括（3*4=12）

![image-20220830165619788.png](https://images-1318884142.cos.ap-guangzhou.myqcloud.com/images/202306232103885.png)


算法的本质是通过在**Minkowski Sum**中，构造simplex，如果simplex包括原点，那么存在交集，相交

support为了使得每次往simplex增加的点，都是**Minkowski Sum**外轮廓的点

##### 算法流程

GJK通过构建Simplex来不断迭代，逼近原点：

初始化Simplex：给定一个方向D，找到起始点 A = Support(D)，将A插入Simplex

更新寻找方向D: D = -A

找到新的点 **A ‘= Support(D) = Support(-A); if dot(A’, D) < 0:return false**

//判断新的点与上一个点，是否横跨原点；

//A、B1：dot<0，说明过原点做一条垂直-A的直线，可以将凸包和原点分割开，B点在凸包的外侧，==凸包不可能包含原点==，return false

![image-20221010094314906.png](https://images-1318884142.cos.ap-guangzhou.myqcloud.com/images/202306232103291.png)


进入NearestSimplex：

当前Simplex阶数<期望Simplex阶数：

找到原点与当前Simplex最近点B，朝着最近接原点的方向迭代 D = -B，增加Simplex阶数

当前Simplex阶数=期望Simplex阶数：

判断原点是否在Simplex中，如果在，return true;否则，找到原点与Simplex最近点B，丢弃当前Simplex中最远点，阶数-1，朝着最近接原点的方向迭代 D = -B，增加Simplex阶数

迭代的终止条件：①**A = Support(-A): if dot(A, D) < 0:return false**，原点在凸包外侧

②到达迭代次数，终止循环，return false

③Simplex包含原点 return ture

![image-20220831152445603.png](https://images-1318884142.cos.ap-guangzhou.myqcloud.com/images/202306232105371.png)


##### 算法实现

GJK类似ICP，是一个迭代优化的过程：通过逐步构建**Simplex**来求解A-B到原点的最短距离
```
bool GJK(  
     const Collider* colliderA,  
     const Collider* colliderB)  
 {  
     // Get initial support point in any direction  
     vector3 support = Support(colliderA, colliderB, vector3::unit_x);  
     // Simplex is an array of points, max count is 4  
     Simplex points;  
     points.push_back(support);  
       
     // New direction is towards the origin  
     vector3 direction = -support;  
        
     while (true) {  
         support = Support(colliderA, colliderB, direction);  
 ​  
         if (support.dot(direction) <= 0) {  
             return false; // no collision  
         }  
 ​  
         points.push_back(support);  
         if (NextSimplex(points, direction)) {  
             return true;  
         }  
     }  
 }

 bool NextSimplex(  
     Simplex& points,  
     vector3& direction)  
 {  
     switch (points.size()) {  
         case 2: return Line       (points, direction);  
         case 3: return Triangle   (points, direction);  
         case 4: return Tetrahedron(points, direction);  
     }  
    
     // never should be here  
     return false;  
 }

**support**函数直接暴力遍历点乘即可

**NextSimplex**：

**LIne**

 bool Line(  
     Simplex& points,  
     vector3& direction)  
 {  
     vector3 a = points[0];  //points是前插，points[0]是最新加入的点  
     vector3 b = points[1];  
 ​  
     vector3 ba = a - b;  
     vector3 bo =   - b;  
    
     direction = ba.cross(bo).cross(ba); //在oab平面内，并且垂直ab的方向，构造三角形  
 ​  
     return false;  
 }
```
 

Line：找到AB线段距离原点最近点C，CO为新的投影方向

原点不可能出现区域：

O1：因为上次搜索是延AO方向，所以原点不可能落在A的左侧

O3：if (support.dot(direction) <= 0) ,所以原点不可能落在B的右侧

可能出现区域：

O2：原点落在线段AB中间，最近点C为O2到AB的垂足，更新搜索方向CO=(ba x ao) x ba

![image-20221010094711503.png](https://images-1318884142.cos.ap-guangzhou.myqcloud.com/images/202306232106019.png)


**Triangle**

bool Triangle(
	Simplex& points,
	vector3& direction)
{
	vector3 a = points[0];
	vector3 b = points[1];
	vector3 c = points[2];

	vector3 ab = b - a;
	vector3 ac = c - a;
	vector3 cb = b - c;
	vector3 co =   - c;
 
	vector3 abc = ab.cross(ac);	//face vector
 
	if (SameDirection(abc.cross(cb), co)) {		//O5		
			points = { b, c };	
			//direction = abc.cross(cb);	
			return Line（points,direction）;
	}
 	if (SameDirection(abc.cross(ac), co)){}		//O6
			points = { a, c };	
			direction = abc.cross(ac);	
			return Line（points,direction）;	
	}
	if (SameDirection(abc, co)) {
		direction = abc;
	}
	else {
		points = { a, c, b };	//注意面片索引绕序
		direction = -abc;
	}

	return false;
}

原点不可能出现区域：

O1：因为第一次搜索是延AO方向，所以原点不可能落在该区域

O2：同上

O3：if (support.dot(direction) <= 0) ,所以原点不可能落在该区域

O4：延AB垂线方向，找到C，所以原点不可能落在O4

可能出现区域：

O5：if (SameDirection(abc.cross(cb), co)) = true BC是最近边，Simplex回退，删去A，重新查找搜索方向，因为O点的最近点可能不在线段上

O6：if (SameDirection(abc.cross(ac), co)) = true AC是最近边，Simplex回退，删去B，重新查找搜索方向，因为O点的最近点可能不在线段上

O7：if (SameDirection(abc.cross(cb), co)) = false && if (SameDirection(abc.cross(ac), co)) = false

二维情况下，已经终止搜索，return true

三维情况下，说明原点投影D在ABC内部，DO为新的搜索方向，需要区分O是在ABC的朝向，DO=- abc/abc

![image-20221010113154106.png](https://images-1318884142.cos.ap-guangzhou.myqcloud.com/images/202306232106614.png)


**Tetrahedron**

同上，忽略abc

bool Tetrahedron(
	Simplex& points,
	vector3& direction)
{
	vector3 a = points[0];
	vector3 b = points[1];
	vector3 c = points[2];
	vector3 d = points[3];

	vector3 da = a - d;
	vector3 db = b - d;
	vector3 dc = c - d;
	vector3 do =   - d;
 
	vector3 acd = da.cross(da);
	vector3 adb = db.cross(da);
	vector3 bdc = dc.cross(db);
 
	if (SameDirection(acd, do)) {	
		points = {a,c,d}
		//direction = acd;
		return Triangle（points， direction）;
	}
		
	if (SameDirection(adb, do)) {
		points = {a,d,b}
		//direction =adb
		return Triangle（points， direction）;
	}
 
	if (SameDirection(bdc, do)) {
		points = {b,d,c}
		//direction = bdc;
		return Triangle（points， direction）;
	}
 
	return true;
}

![image-20220831113812062.png](https://images-1318884142.cos.ap-guangzhou.myqcloud.com/images/202306232106636.png)


##### 参考链接

- 和自己推导不一致：[Winter's Blog](https://blog.winter.dev/2020/gjk-algorithm/)
    
- 和自己推导一致[2D GJK](https://www.youtube.com/watch?v=ajv46BSqcK4)
    
- Bullet，重量级引擎，全局搜btGjkPairDetector可找到GJK代码
    

[https://github.com/bulletphysics/bullet3](https://github.com/bulletphysics/bullet3)

- reactphysics3d，非产品级的轻量物理引擎，适合学习用：
    

[https://github.com/DanielChappuis/reactphysics3d](https://github.com/DanielChappuis/reactphysics3d)

#### 基本图元的碰撞检测

##### point in line segment

①找p到line segement的最近点，通过投影判断p是否落在线上

②判断点到最近点的距离 与 tolerance

参考：geometrictools.com

##### point in triangle

2D：计算重心坐标

参考：[Point in triangle test (blackpawn.com)](https://blackpawn.com/texts/pointinpoly/default.html)

##### point in rectangle

! (p.x < rectangle.min.x || p.x >rectangle.max.x || p.y < rectangle.min.y || p.y >rectangle.max.y)

##### line intersect rectangle

①point in rectangle?

②edge intersect rectangle

判断线段 line = start + t * (end - start）,0<t<1

判断线段在x轴方向与rectangle的交集 t1=（rectangle.l - start.x)/ (end-start).x t2=（rectangle.r - start.x)/ (end-start).x

是否与0，1有交集（是否在x轴方向相交），输出与（0，1）交集 new bounding

再判断y轴的交集和new bounding是否存在交集

参考：games101 ray intersect box

##### triangle intersect rectangle

①point in rectangle

②edge intersect rectangle

③检测三角形是否包含了rectangle，只用检测矩形的中心 是否落在三角形内即可 此处对博客的做法进行了改进，从评论中得到的灵感

参考：[Super fast triangle/rectangle intersection test – Seb Lee-Delisle](https://seblee.me/2009/05/super-fast-trianglerectangle-intersection-test/)

##### eillipse intersect rectangle

①初步筛选

计算椭圆在rectangle轴方向的投影，如果点落在(rectangle.b-height/2,rectangle.l-width/2) 到 (rectangle.t+height/2,rectangle.r+width/2) 范围内，判定为相交

②精碰撞

检测圆心是否落在四个角点

参考：[https://www.geometrictools.com/Documentation/IntersectionRectangleEllipse.pdf](https://www.geometrictools.com/Documentation/IntersectionRectangleEllipse.pdf)

#### TIPS

**在更新simplex时，仔细检查normal和面片的朝向！！!**

踩过大坑

#### 小结

映射屏幕/NDC，有BUG

Farmebuffer picker仅适用无遮挡

判断顶点和平面关系，需要对特殊情况特殊处理

SAT、GJK：处理严谨，GJK性能>SAT

# 9.5~9.21 常规图元绘制

TODO：网格化circle、sphere会有精度损失，后期对框架理解加深后，改用SDF

9.5~9.8 Rust基础回顾+高级补充

9.9-9.13 math理解

9.14~9.17 creat_geometry、测试示例

[C++ 生成球体网格 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/364320044)

[https://zhuanlan.zhihu.com/p/88889181](https://zhuanlan.zhihu.com/p/88889181)

球的纹理映射：[Best way to unwrap a sphere? - Support / Materials and Textures - Blender Artists Community](https://blenderartists.org/t/best-way-to-unwrap-a-sphere/614600/4)

9.19 cube修改、BOX3增加、FFI导出

9.20 重新配置环境、QT测试

9.21 增加point、line；提交代码

9.22 修改review意见

# 9.22~9.30 框选Object实现

### 杂项

**BV的选择**

对视锥体和包围盒进行碰撞检测，包围盒的形式 按需选取

球：表达形式最简单，碰撞检测开销最小，误差最大（球体与网格贴合程度最差，最容易出现误判）

OBB精度更高，但性能开销较大且局部处理也较为麻烦；

AABB精度较低，但是性能开销小，且与**轴对齐**的性质，使得某些操作变得方便

### 定义框选视锥体

##### 视锥体相交检测

#### 视锥体定义

输入屏幕坐标：vec2(x1,y1) vec2(x2,y2) ->min、max

##### **屏幕坐标 to NDC空间**

屏幕坐标定义

![image-20220923150739782.png](https://images-1318884142.cos.ap-guangzhou.myqcloud.com/images/202306232107678.png)


NDC空间定义: x[-1,1] y[-1,1] z[0,1]

![image-20220923151549428.png](https://images-1318884142.cos.ap-guangzhou.myqcloud.com/images/202306232107787.png)


注：通过屏幕坐标，可映射到NDC的x,y坐标

对于Z坐标，①该点被绘制，则Z坐标被存在Z-buffer中，②该点位于near（z=0）、far(z=1；③该点Z值被丢弃，无法确定NDC空间的Z值

视锥体的屏幕定义在near,far

min、max->NCD:(x,y,0) (x,y,0) (x,y,0) (x,y,0)

(x,y,1) (x,y,1) (x,y,1) (x,y,1)

**NCD视锥体**

x0<x<x1
y0<y<y1
0<z<1

TIPS1:不管框选的范围生成**斜视锥体**还是**正视锥体**，都是通过Mproj来投影到NDC空间，并且从相机发射ray，与near交点P1、与far交点P2, p1、p2在NDC空间的xy是相同的；因此可推论，==**框选的视锥体在NDC空间始终为一个长方体，这是由Mproj所决定的==**
![image-20220823112355420.png](https://images-1318884142.cos.ap-guangzhou.myqcloud.com/images/202306232108633.png)

##### NDC to world

world to NDC: point(NDC) = point(world) * Mproj

NDCto world : point(world) = point(NDC) * **Mproj-1**

NCD:(x,y,0) (x,y,0) (x,y,0) (x,y,0) ->world:(x,y,near) (x,y,near) (x,y,near) (x,y,near)

(x,y,1) (x,y,1) (x,y,1) (x,y,1) (x,y,far) (x,y,far) (x,y,far) (x,y,far)

**world视锥体**

6*plane
8*point
6*ndc_postion

plane快速定义：[游戏中的剔除技术（二）视锥剔除和硬件剔除 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/437399913)

$$
Mv=v'
$$
$$
\left\{
\begin{matrix}
x*m_{11}+y*m_{12}+z*m_{13}+m_{14}\\
x*m_{21}+y*m_{22}+z*m_{23}+m_{24}\\
x*m_{31}+y*m_{32}+z*m_{33}+m_{34}\\
x*m_{41}+y*m_{42}+z*m_{43}+m_{44}\\
\end{matrix}
\right\}
=
\left\{
\begin{matrix}
x'\\
y'\\
z'\\
w'\\
\end{matrix}
\right\}
=
\left\{
\begin{matrix}
x'/w'\\
y'/w'\\
z'/w'\\
1\\
\end{matrix}
\right\}
$$

其中：

- V：相机坐标系下顶点（x,y,z,1）
    
- M：Mproj
    
- V1：NDC坐标系下顶点，w=1转换齐次坐标
    

视锥体在NDC空间定义：
$$
-1<x<1\\-1<y<1\\-1<z<1$$

#### 视锥体平面定义

ax+by+cz=d

d:有符号距离，原点到平面的距离，沿法线为正，否则为负

d>0：说明原点在平面的背面

- right: m41-m11, m42-m12, m43-m13, m14-m44
    
- left: m41+m11, m42+m12, m43+m13, m44+m14
    
- top: m41-m21, m42-m22, m43-m23, m24-m44
    
- bottom: m41+m21, m42+m22, m43+m23, m44+m24
    
- near: m41-m31, m42-m32, m43-m33, m34-m44
    
- far: m41+m31, m42+m32, m43+m33, m44+m34
    

##### 右平面

**相机坐标系下**一点V，在视锥体的内部，则说明V要在视锥体右平面的左侧，等同于**NDC空间**下， V1.x<1
$$
x'/w'<1
x'/w'-1<0
\\(v*row1)/(v*row4)-1<0\\0<v*(row4-row1)\\ax+bx+cy=d:\\m_{14}-m_{44}<x*(m_{41}-m_{11})+y*(m_{42}-m_{12})+z*(m_{43}-m_{13})
$$
至此，给出了视锥体右平面的定义，平面的法向朝向视锥体内部，右平面左侧的点到该平面的距离>m14-m44

##### 左平面
$$
-1<x'/w'\\0<v*(row4+row1)\\m_{14}+m_{44}<x*(m_{41}+m_{11})+y*(m_{42}+m_{12})+z*(m_{43}+m_{13})
$$

-1<v1.x

[游戏中的剔除技术（二）视锥剔除和硬件剔除 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/437399913)

### 粗剔除

对场景中的mesh构建Bouding box，通过BVH管理Bouding box

考虑到需要两两合并，AABB合并方便；但是，AABB不能贴合mesh,会检测错误结果，但是这种结果往往出现在相交的时候，对相交的叶节点单独构造OBB再对mesh进行GJK判断？

①BVH子节点不在视锥体中；略过该子节点下所有叶节点

②BVH子节点完全在视锥体中；所有叶节点无需交叉测试，直接选取

③BVH子节点与视锥体相交，如果当前子节点是叶节点，进一步在mesh层面进行碰撞检测；如果当前子节点不是叶节点，插入子节点的child进队列，继续检测

### 精剔除

对检测相交的OBB，在face层次上与视锥体进行碰撞检测

对mesh建立BVH（AABB），测试子节点与相交面碰撞

①子节点在相交面外，舍弃子树

②子节点在相交面内，return ture

③子节点与相交面相交，向下遍历

叶节点为face，对face与相交面进行，碰撞，return ture

### 9.26

由于BV与mesh之间，存在一定的精度失真，会出现一部分的误判

- BV在视锥体内部，mesh一定在视锥体内部
    
- BV在视锥体外部，mesh一定在视锥体外部
    
- BV与视锥体相交，mesh可能在视锥体内部，可能在外部，也可能相交
    

因此，需要在mesh层面对BV与视锥体相交的情况，进一步做碰撞检测

判断face与视锥体的相交情况

- 所有face都在视锥体外，mesh在视锥体外
    
- 所有face都在视锥体内，mesh在视锥体内
    
- else 相交
    

#### face&视锥体碰撞检测

由于BV与mesh之间，存在一定的精度失真，会出现一部分的误判

- BV在视锥体内部，mesh一定在视锥体内部
    
- BV在视锥体外部，mesh一定在视锥体外部
    
- BV与视锥体相交，mesh可能在视锥体内部，可能在外部，也可能相交
    

因此，需要在mesh层面对BV与视锥体相交的情况，进一步做碰撞检测

判断face与视锥体的相交情况

- 所有face都在视锥体外，mesh在视锥体外
    
- 所有face都在视锥体内，mesh在视锥体内
    
- else 相交
    

对mesh建立BVH，先用AABB判断，再到face判断

遍历face的三个顶点，判断是否在视锥体内部

Mproj*V = Vndc

直接判断Vndc是否在视锥体NDC区间内
![image-20220924172211141.png](https://images-1318884142.cos.ap-guangzhou.myqcloud.com/images/202306232112206.png)


对于所有顶点都在外部的情况做GJK

[OpenGL @ Lighthouse 3D - View Frustum Culling Tutorial (uni-bremen.de)](https://cgvr.cs.uni-bremen.de/teaching/cg_literatur/lighthouse3d_view_frustum_culling/index.html)

# 2023

## 2月

### **静态BVH**

#### 概述

层次包围体（Bounding volume hierarchies, BVH）是一种基于图元（Primitive，构成场景的基本元素，如三角形、球面等）划分的空间索引结构。

区别于KD树、八叉树这类空间划分的结构，BVH基于图元划分，同一个图元只会出现在一个叶节点中，但是不同节点的空间是存在重叠的

![image-20221020134644324.png](https://images-1318884142.cos.ap-guangzhou.myqcloud.com/images/202306232112883.png)
BVH可以对碰撞检测等流程进行加速，大体思路为从root开始，通过与子节点的计算，略过其下叶节点的计算结果，优化**暴力递归**的性能开销

构建的方式有自上而下；自下而上

下面以自上而下来说明：**流程简单，但构建性能开销大**

自下而上：见LBVH

#### BVH构建

- 计算场景中每一个图元的AABB包围盒、质心（一般取包围盒的中心）
    
- 根据不同的划分策略构建树状索引结构。
    
- 将得到二叉树转化更加紧凑的表示形式（无指针，内存连续）
    

两种最简单的划分方法是：

- 中点划分：取坐标轴跨度的中点 tmid=tmax+tmin2 ，若节点的坐标小于 tmin 则将其划分到左节点，否则将其划分到右键点
    
- 等量划分：最左边的 n2 个被划分到左节点，最右边的 n2 个被划分到左节点
    

当图元分布不均匀的时候，上面两种方法得到的划分结果会变得很差。

如左图所示，当图元分布不均时，划分的两个节点之间的空间重合度较高，如果光线落在重合区域，那么需要对两个节点都进行计算

![image-20221020145547858.png](https://images-1318884142.cos.ap-guangzhou.myqcloud.com/images/202306232113463.png)


#### SAH划分

Surface Area Heuristic是一种启发式的空间划分方法，对BVH的划分方式进行改进，提高BVH的搜索性能，本质上是对几种划分方式进行事前预估，沿着时间开销较小的方式进行划分

假设当前节点下，存在n个物体，对每个物体进行碰撞检测的代价为t(i)，则暴力遍历的总代价为：

![image-20221020150717818.png](https://images-1318884142.cos.ap-guangzhou.myqcloud.com/images/202306232113012.png)


现在利用某种划分方式将节点分为A、B两个子节点，现在的遍历代价为：

![image-20221020152110745.png](https://images-1318884142.cos.ap-guangzhou.myqcloud.com/images/202306232113541.png)


其中，P（A）为ray与A节点碰撞的概率，AB存在较大的空间重叠区域时，PA+PB可能>1，不重叠时，PA+PB<1；trav为遍历树结构的代价

SAH对上式进行简化：

- 假设所有物体的检测代价都为1；
    
- trav的性能开销<碰撞检测，trav=0.125;
    
- 光线落在A区间的概率PA：A的包围盒**表面积**越大，（前提：光线落在A+B），光线落在A的概率越大 PA=S（A）/S（C）
    
    **==TIps：为啥不用体积呢？？？==**
    
    A包含于C，光线穿过A必穿过C，因此光线同时穿过AC的概率，就与他们的表面积有关，S（A）/S（C）
    

![image-20221020153048827.png](https://images-1318884142.cos.ap-guangzhou.myqcloud.com/images/202306232113478.png)


a：A的mesh数量

SAH划分可以先找到x,y,z中，AABB**跨度比较长的一个轴**（也可以3个轴都进行测试），沿着该轴，对节点下的mesh中心点进行排序，在该轴上划分n个桶，此时左右子树有n-1中划分方式，预估这n-1种方式的性能开销，选择最小的划分方式

tips：SAH本质是对不同划分方式的性能预估，划分方式并不一定是上述方式

![image-20221020173410834.png](https://images-1318884142.cos.ap-guangzhou.myqcloud.com/images/202306232113060.png)


![image-20221020173423218.png](https://images-1318884142.cos.ap-guangzhou.myqcloud.com/images/202306232113492.png)


如果所有图元的质心位置都相同，直接建立一个根节点，根节点中存放所有节点，反正都要暴力遍历，划分没有意义

#### 算法流程
```
BVHBuildNode* BVHAccel::recursiveBuildSAH(std::vector<Object*> objects)
{
    BVHBuildNode* node = new BVHBuildNode();

    // Compute bounds of all primitives in BVH node
    Bounds3 bounds;
    for (int i = 0; i < objects.size(); ++i)
        bounds = Union(bounds, objects[i]->getBounds());	//计算所有mesh的bounds
    if (objects.size() == 1) {				//叶节点处理
        // Create leaf _BVHBuildNode_
        node->bounds = objects[0]->getBounds();
        node->object = objects[0];
        node->left = nullptr;
        node->right = nullptr;
        node->area = objects[0]->getArea();
        return node;
    }
    else if (objects.size() == 2) {			//左右子树都是叶节点
        node->left = recursiveBuild(std::vector{objects[0]});
        node->right = recursiveBuild(std::vector{objects[1]});

        node->bounds = Union(node->left->bounds, node->right->bounds);
        node->area = node->left->area + node->right->area;
        return node;
    }
    else {
        Bounds3 centroidBounds;
        for (int i = 0; i < objects.size(); ++i)
            //找最大pMax/2  最小pMin/2
            centroidBounds =
                Union(centroidBounds, objects[i]->getBounds().Centroid());
        int dim = centroidBounds.maxExtent();	//确定划分轴
        switch (dim) {							//按中心延轴进行排序
        case 0:
            //x轴为顺序 从小到大顺序  return写的是排序模式
           	//此时可用快排：https://blog.csdn.net/ycrsw/article/details/124331686
            std::sort(objects.begin(), objects.end(), [](auto f1, auto f2) {
                return f1->getBounds().Centroid().x <
                       f2->getBounds().Centroid().x;
            });
            break;
        case 1:
            std::sort(objects.begin(), objects.end(), [](auto f1, auto f2) {
                return f1->getBounds().Centroid().y <
                       f2->getBounds().Centroid().y;
            });
            break;
        case 2:
            std::sort(objects.begin(), objects.end(), [](auto f1, auto f2) {
                return f1->getBounds().Centroid().z <
                       f2->getBounds().Centroid().z;
            });
            break;
        }
        int bulks=10;	//子区间划分数量
        int mincostIndex=0;	//子区间划分方式
        float minCost=std::numeric_limits<float>::infinity(); //最小花费 初始化为无穷
        for (int i = 1; i < bulks; i++){
            //划分左右节点
            auto beginning = objects.begin();
            auto middling = objects.begin() + (objects.size() * i / B);
            auto ending = objects.end();
            auto leftshapes = std::vector<Object*>(beginning, middling);
            auto rightshapes = std::vector<Object*>(middling, ending);
            
            //求左右包围盒:
            Bounds3 leftBounds, rightBounds;
            for (int k = 0; k < leftshapes.size(); ++k)
            leftBounds = Union(leftBounds, leftshapes[k]->getBounds().Centroid());
            for (int k = 0; k < rightshapes.size(); ++k)
            rightBounds = Union(rightBounds, rightshapes[k]->getBounds().Centroid());
            float SA = leftBounds.SurfaceArea(); //SA
            float SB = rightBounds.SurfaceArea(); //SB
            float cost = 0.125 + (leftshapes.size() * SA + rightshapes.size() * SB) / SN; //计算花费
            if (cost < minCost) //如果花费更小，记录当前坐标值
            {
            minCost = cost;
            mincostIndex = i;
            }
        }
           //找到mincostIndex后的操作等同于BVH
            auto beginning = objects.begin();
            auto middling = objects.begin() + (objects.size() * mincostIndex / B);//划分点选为当前最优桶的位置
            auto ending = objects.end();
            auto leftshapes = std::vector<Object*>(beginning, middling); //数组切分
            auto rightshapes = std::vector<Object*>(middling, ending);

            assert(objects.size() == (leftshapes.size() + rightshapes.size()));

            node->left = recursiveBuild(leftshapes); //左右开始递归
            node->right = recursiveBuild(rightshapes);
            node->bounds = Union(node->left->bounds, node->right->bounds);//返回pMin pMax构成大包围盒
    }

    return node;
} 
```



#### Trick

##### Flatten（为遍历压实BVH）

BVH的节点通过指针来指向children来访问，对于静态的BVH，可以将所有节点储存在数组中，第一个children的索引=parent+1；第二个children的索引=parent+offest；每个node仅存offest即可，通过下标来加速访问

同时，也可以更快的遍历到所有的节点

参考：PBRT

##### Bounding transom

==在scene中，BoundBox往往建立在其模型坐标系下，如何快速将BoundBox从模型坐标系还原到世界坐标系中？==

常规方法：

原始Box的Pmax、Pmin经过变换后，并不一定仍在是这两个顶点，需要将Box的8个顶点都进行变换，再对这8个顶点进行比较

快速解法：

center = (Pmax+Pmin)/2

r = (Pmax-Pmin)/2

8个顶点为 center+-r的组合变换 2(xmin、xmax) * 2(ymin、ymax)* 2(zmin、zmax)

![image-20221020162609934.png](https://images-1318884142.cos.ap-guangzhou.myqcloud.com/images/202306232114953.png)


变换后的8个顶点的齐次形式如下：

![image-20221020162620791.png](https://images-1318884142.cos.ap-guangzhou.myqcloud.com/images/202306232114687.png)


变换后的Box的Pmin、Pmax:

![image-20221020162734203.png](https://images-1318884142.cos.ap-guangzhou.myqcloud.com/images/202306232114622.png)


M*（x,y,z,1）可以拆分为4个列向量相加：M0 * x + M1 * y + M2 * z + M3 * 1

并且min(A+B) = minA + minB，下面的做法减少了计算量，增加了计算数据的复用性

加速后：6次列向量*标量，6次max/min向量，8次向量加法 >8个顶点的旋转平移+8个顶点的min/max

    Vector3f a1 = m_col0 * pMin.x;	//M0*x
    Vector3f a2 = m_col0 * pMax.x;

    Vector3f b1 = m_col1 * pMin.y;
    Vector3f b2 = m_col1 * pMax.y;

    Vector3f c1 = m_col2 * b.pMin.z;
    Vector3f c2 = m_col2 * b.pMax.z;
    float w = m[3][3];
    Vector3f pmin_  =  Min(a1,a2) + Min(b1,b2) + Min(c1,c2) + m_col3;// Min(vec3,vec3):新的向量的x=min(a1.x,a2.x).....
    Vector3f pmax_  =  Max(a1,a2) + Max(b1,b2) + Max(c1,c2) + m_col3;
    box.pMin = {pmin_.x/w,pmin_.y/w,pmin_.z/w};	//标准化齐次坐标。x,y,z,w	-> x',y',z',1
    box.pMax = {pmax_.x/w,pmax_.y/w,pmax_.z/w};
    return box;

参考：pbrt

#### 参考链接

[pbrt 4.3](https://github.com/kanition/pbrtbook)

[PBRT-E4.3-层次包围体(BVH)（一） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/50720158)

[（深度解析）GAMES 101 作业6：BVH与SAH(Surface Area Heuristic) - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/475966001)

### HLBVH

本质上一种静态bvh构建方法，在原有sah的基础上，先做LBVH，对所有子节点进行莫哈顿编码，将包围盒质心映射到一维上，将其排序后，对其进行分组，并行的对每个小组构建子树，再以这些子树的根节点基于SAH来构造BVH

- 计算所有图元的包围盒及质心，以及根节点包围盒
    
- 计算所有图元质心相对于包围盒的百分比坐标，将百分比坐标放大到整数级，进行莫哈顿编码
    
    - 计算图元质心在包围盒中的百分比坐标，在乘上1024=2^10，此时x、y、z的最低十位用来存储数据
        
    - 对x、y、z进行莫顿编码,在对y左移一位，z左移两位拼接起来
        
        - moten(x) | moten(y)<<1 | moten(z)<<2
            
        - 3_n->x，3_n+1->y, 3n+2->z
            
- 对莫哈顿编码进行基数排序，并维护映射
    
    根据莫顿码的有效位数来计算桶（2^n，而非10进制的10）
    
    先对n个低位码，进行第一次排序
    
    mask=1<< n-1
    
    bucket = 1 << n
    
    通过 morton&mask，标记每个桶的元素数量
    
    详见代码
    
    再对n,2n位码，进行第二次排序
    
    .....
    
- 对莫哈顿编码分组
    
- 并行构造子树
    
- 以子树作为叶节点基于SAH自上而下，构造BVH
    

```
BVHBuildNode *BVHSystem::HLBVHBuild(
    ComponentHandle<BVHAccel> bvhAccel,
    MemoryArena &arena,
    const std::vector<BVHObjInfo> &objInfo,
    int *totalNodes,
    std::vector<ObjectID> &orderedObjs)  {

    // 1. 计算所有物体中心坐标的包围盒
    BBox bounds;
    for (const BVHObjInfo &pi : objInfo)
        bounds = Union(bounds, pi.centroid);

    // 2. 并行计算每所有物体的MortonObj信息
    std::vector<MortonObj> mortonObjs(objInfo.size());
    ParallelFor([&](int i) {
        // 莫顿码共10位
        constexpr int mortonBits = 10;
        constexpr int mortonScale = 1 << mortonBits;
        mortonObjs[i].objIndex = objInfo[i].objNumber;
        // centroidOffset是该obj中心在包围盒里的百分比坐标
        Vector3dF centroidOffset = bounds.Offset(objInfo[i].centroid);
        // 把百分比坐标映射到[0, 1024]，然后编成莫顿码
        mortonObjs[i].mortonCode = EncodeMorton3(centroidOffset * mortonScale);
    }, objInfo.size(), 512);

    // 3. mortonObjs数组做基数排序
    RadixSort(&mortonObjs);

    // 4. 按照莫顿码的高位是否一样（都属于同一个grid），对所有物体分组
    // 如果物体分布很稀疏的话，就是一个物体一个treelet, nObjs为1
    // （treelet可以叫做幼树，意指整个BVH树的下层部分的单个子树）
    // 被mask为1的bits有12个，所以总共有2^12=4096个grid （treelet）
    // 因为有3个维度，所以单维度上是2^4=16个grid
    std::vector<LBVHTreelet> treeletsToBuild;
    for (int start = 0, end = 1; end <= (int)mortonObjs.size(); ++end) {
        uint32_t mask = 0b00111111111111000000000000000000;
        if (end == (int)mortonObjs.size() ||
            ((mortonObjs[start].mortonCode & mask) !=
            (mortonObjs[end].mortonCode & mask))) {
            int nObjs = end - start;
            int maxBVHNodes = 2 * nObjs;
            BVHBuildNode *nodes = arena.Alloc<BVHBuildNode>(maxBVHNodes, false);
            treeletsToBuild.push_back({ start, nObjs, nodes });
            start = end;
        }
    }

    // 5.开始构造BVH了
    // 5.1 这段代码最关键的就是并行调用emitLBVH，和统计totalNodes
    // 注意，这里构建了n个BVH子树，n=treeletsToBuild.size()
    // 下一个步骤会把这n个BVH子树当成n个物体，和recursiveBuild一样自顶向下构建BVH
    std::atomic<int> atomicTotal(0), orderedObjsOffset(0);
    orderedObjs.resize(bvhAccel->objs.size());
    ParallelFor([&](int i) {
        // Generate _i_th LBVH treelet
        int nodesCreated = 0;
        const int firstBitIndex = 29 - 12;
        LBVHTreelet &tr = treeletsToBuild[i];
        tr.buildNodes = emitLBVH(bvhAccel, tr.buildNodes, objInfo, &mortonObjs[tr.startIndex],
            tr.nObjs, &nodesCreated, orderedObjs,
            &orderedObjsOffset, firstBitIndex);
        atomicTotal += nodesCreated;
    }, treeletsToBuild.size());
    *totalNodes = atomicTotal;

    // 5.2 把std::vector<LBVHTreelet>的buildNodes 放进 finishedTreelets
    std::vector<BVHBuildNode *> finishedTreelets;
    finishedTreelets.reserve(treeletsToBuild.size());
    for (LBVHTreelet &treelet : treeletsToBuild)
        finishedTreelets.push_back(treelet.buildNodes);

    // 5.3 构造BVH的上层部分
    return buildUpperSAH(arena, finishedTreelets, 0, finishedTreelets.size(),
        totalNodes);
}
```


源码：[mmp/pbrt-v4:](https://github.com/mmp/pbrt-v4)

参考：PBRT-V4

[Bounding Volume Hierachy of pbrt 解析(2) HLBVH (qiujiawei.com)](https://www.qiujiawei.com/bvh-2/#:~:text=注意，emitLBVH依然采用自顶向下的构建流程，但是却可以多线程并行构建n,(1<%3Dn<%3D4096)个grid的BVH，这是第一个性能优化点；第二个性能优化点，在于emitLBVH构造BVH是线性的，即O (n)时间复杂度，这归功于前面的莫顿码排序。)

#### 踩坑

LBVH构造子树的过程是二分的，BVH会相对平衡，叶节点在分支的最底层，如果此时有一个超级大的bounding，其包含了许多集中且细小的bounding，如果这个超大bounding出现在树的最底层，那么沿着其一路向上，包围盒都会很大，LVBH的构造过程中，只有中心点的信息，没有bounding的信息，不足以对这种情况进行区分
![image-20230222181348820.png](https://images-1318884142.cos.ap-guangzhou.myqcloud.com/images/202306232117951.png)


==BUT！！！==

BVH是二叉树，2^20= 1，048，576个model，在树接近平衡的情况下，树高20，那么这个超大的包含节点只会影响他的一系列父节点，这些父节点的个数=20，**全局来看 总的cost变化不会特别大；但是，会导致每次点选到那个超大节点，都无法判空，要沿着根节点一直走到那个超大节点的地方**

所以，虽然全局cost变化不大，但是会明显降低搜索效率

目标：将出现在BVH底层的超大叶节点，放置在BVH比较靠根节点的位置，降低全局cost

①动态BVH，一个个insert节点的方式

②基于SAH，前几次可能无法划分，后面肯定存在一次划分，将超大的的bounding提前划分出来
![image-20230222182756445.png](https://images-1318884142.cos.ap-guangzhou.myqcloud.com/images/202306232118168.png)
![image-20230222182904893.png](https://images-1318884142.cos.ap-guangzhou.myqcloud.com/images/202306232118974.png)

### 动态BVH

#### BVH的节点操作

[(77条消息) Box2d源码学习<六>动态树的实现_扭曲45的博客-CSDN博客](https://blog.csdn.net/cg0206/article/details/8293049)

前置概念：直接操作的节点都是叶节点，间接影响的都是父节点

**增加节点**

①找到插入位置

②局部节点操作

空树：插入节点N为root节点

//单子树（A）：不存在单子树，构造过程中会自动退化到父节点

双子树（A、B）：A与N构成新的子节点，代替原有A的位置；向上更新父节点

③传播更新BVH

**删除节点**

单个节点：变成空树

多个节点（A、B、N)：删除节点N，A为B的父节点，A、B退化为B；向上更新父节点

**旋转、平移、缩放节点**

①更新后节点包围盒<原本父节点包围盒，仅更新叶节点

②else：先删除节点，再插入节点

#### 树的旋转

①旋转树，保持平衡

②搜索效率最优:待研究 难点在于如何找到应该被优化的节点，剩下操作为移除他的两个子节点，再插入

③避免链表插入

[简单参考：平衡二叉树 —— 如何优雅的进行旋转 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/438604092)

[ErinCatto_DynamicBVH_Full.pdf (box2d.org)](https://box2d.org/files/ErinCatto_DynamicBVH_Full.pdf)

**此处仅讨论①③的情况**

树的平衡：每个节点的平衡因子绝对值 <= 1, 保持树的平衡，可以减低root的高度，提高搜索效率

BVH的旋转，优先考虑如何==降低全局Cost==，再考虑树的平衡因子？ ：理解优先，没有推导

并且BVH的旋转，对全局的cost仅位于局部
![image-20230202160744052.png](https://images-1318884142.cos.ap-guangzhou.myqcloud.com/images/202306232120937.png)
![image-20230202161642098.png](https://images-1318884142.cos.ap-guangzhou.myqcloud.com/images/202306232120770.png)


[GitHub - erincatto/dynamic-tree: Dynamic tree：：Function Rotato](https://github.com/erincatto/dynamic-tree)

**旋转节点的变化分三种情况，① OldParent的B节点是叶子节点，交换B节点和C节点的子节点FG ②Old的C节点是叶子节点，交换C节点和B节点的DE节点 ③OldParent的BC节点都不是叶节点，交换B和FG、交换C和DE，取决于那种交换方式，cost最小**

#### 树的重建

√自上而下

×自下而上

#### BVH更新传播范围

兄弟节点之间可能重叠，可能不重叠，兄弟节点A的变化不会传播到兄弟节点B；

==仅延父节点传播==

删除节点：节点D的删除，使得节点B退化为节点E，Box(E)<=Box(B),向上更新父节点，直到某个父节点的Box无变化

TIPS:对节点A的变化，必须用Box(E+C)与Box(A)进行比较，无法用Box(A)-Box(B-E):因为Box(B-E)可是存在C中，兄弟节点是有重叠情况的
![image-20230201173146279.png](https://images-1318884142.cos.ap-guangzhou.myqcloud.com/images/202306232121069.png)


插入节点：节点L的插入，使得C与L构成新的父节点N；与删除节点类似，Box变化向父节点传播，直到父节点不发生改变
![image-20230201174332632.png](https://images-1318884142.cos.ap-guangzhou.myqcloud.com/images/202306232121917.png)

#### 插入节点的位置（SAH)

利用SAH来评估最优的新节点插入位置

##### 暴力遍历

首先，叶节点的cost是始终不变的，root节点的cost是所有叶节点组成包围盒的开销，也和树的划分方式无关；不同的划分方式，仅对子节点的开销产生影响

因此，将新节点**挨个**与节点，并更新这一系列的父节点cost，其他分支不受印象，统计开销最低的那种插入方式，作为最优插入方式

but!!!。这样做开销太大，每个节点都是潜在的兄弟节点

![image-20221021174243645.png](https://images-1318884142.cos.ap-guangzhou.myqcloud.com/images/202306232121737.png)

direct cost：==上图中的：增加L的额外Cost，为什么用S(11)=S(H+L)，而不是S(11)-SH???==：：原本的10节点：左H，右2；插入节点后，H的开销不变，直接开销是S11+SL，SL在实际计算过程中被约掉，同理▲S1也应该别约掉

inherited cost：容易计算，只要落在他的子节点下，对于父节点的bounds,改变都是一样的 见蓝色公式

##### branch and bound

![image-20221021174743150.png](https://images-1318884142.cos.ap-guangzhou.myqcloud.com/images/202306232122019.png)


前置概念：插入的L一定的叶节点，但是L的兄弟节点不一定是叶节点，也可能是中间节点

目标：寻找cost最少的 L兄弟节点；通过branch and bound，跳过一些节点的遍历，优化性能

初始化：用**优先队列**来存储搜索种子（为方便计算，不仅存储节点，也存储inherited cost）；Cost：L的兄弟节点是root

     let q: Pair<Node, number>[] = [{ p1: this.root, p2: 0.0 }];

每次从优先队列中拿出的节点，都是inherited cost最小的节点

**Cbest的更新**

![image-20221021181205470.png](https://images-1318884142.cos.ap-guangzhou.myqcloud.com/images/202306232122295.png)


if C7<Cbest：更新Cbest = C7，并且node7为当前的最佳兄弟节点

**Clow判断，是否插入子节点**

判断是否需要对node7的子树进行搜索

![image-20221021181811754.png](https://images-1318884142.cos.ap-guangzhou.myqcloud.com/images/202306232122612.png)


Clow的含义：只要L插入在Node7的下面，那么增加的cost一定>Clow，因此Clow>Cbest的话，就没有再继续向下搜索的必要了

if Clow<Cbest：8，9需要被搜索，插入到Q中；否则：8，9被忽略

**每次循环前，先检查是否已经找到了Cbest**

		int index = candidate.index;
		float lowerBoundCost = candidate.inheritanceCost + areaL;
		if (lowerBoundCost > bestCost)
		{
			// 由于有限队列，此时的cost是队列中最小的存在，此时已经找到了最佳cost
			//  Optimum found
			break;
		}

**记录兄弟节点、节点开销**

当种子搜索完成后，保存当前L的最佳兄弟节点，然后L插入到tree中

**参考代码**

[dynamic-tree/tree.cpp at master · erincatto/dynamic-tree · GitHub](https://github.com/erincatto/dynamic-tree/blob/master/src/tree.cpp)

void dtTree::InsertLeafSAH(int leaf)
{
	++m_insertionCount;

	if (m_root == dt_nullNode)
	{
		m_root = leaf;
		m_nodes[m_root].parent = dt_nullNode;
		return;
	}

	dtAABB aabbL = m_nodes[leaf].aabb;
	float areaL = dtArea(aabbL);

	// Stage 1: find the best sibling for this node
	dtCandidateNode candidate;
	candidate.index = m_root;

	int bestSibling = m_root;
	float bestCost;
	{
		const dtNode &node = m_nodes[m_root];
		bestCost = dtArea(dtUnion(node.aabb, aabbL));
		candidate.inheritanceCost = bestCost - dtArea(node.aabb);
	}

	m_heap.clear();
	m_heap.push_back(candidate);

	while (m_heap.size() > 0)
	{
		std::pop_heap(m_heap.begin(), m_heap.end()); // 排序 有限搜索最低间接代价的节点
		candidate = m_heap.back();
		m_heap.pop_back();

		int index = candidate.index;
		float lowerBoundCost = candidate.inheritanceCost + areaL;
		if (lowerBoundCost > bestCost)
		{
			// 由于有限队列，此时的cost是队列中最小的存在，此时已经找到了最佳cost
			//  Optimum found
			break;
		}

		const dtNode &node = m_nodes[index];
		if (node.isLeaf)
		{
			// 先计算当前节点的Cost，再判断是否插入到队列中
			// 此时可以跳过，是因为已经算过节点，且后续无子节点插入队列了
			continue;
		}

		// Child push order doesn't matter since the heap will sort them.

		{
			const dtNode &child1 = m_nodes[node.child1];
			float directCost = dtArea(dtUnion(child1.aabb, aabbL));
			float totalCost = directCost + candidate.inheritanceCost;
			if (totalCost <= bestCost)
			{
				bestCost = totalCost;
				bestSibling = node.child1;
			}

			float inheritanceCost = totalCost - dtArea(child1.aabb);
			if (inheritanceCost + areaL <= bestCost)
			{
				dtCandidateNode candidate1;
				candidate1.index = node.child1;
				candidate1.inheritanceCost = inheritanceCost;
				m_heap.push_back(candidate1);
				std::push_heap(m_heap.begin(), m_heap.end());
			}
		}

		{
			const dtNode &child2 = m_nodes[node.child2];
			float directCost = dtArea(dtUnion(child2.aabb, aabbL));
			float totalCost = directCost + candidate.inheritanceCost;
			if (totalCost <= bestCost)
			{
				bestCost = totalCost;
				bestSibling = node.child2;
			}

			float inheritanceCost = totalCost - dtArea(child2.aabb);
			if (inheritanceCost + areaL <= bestCost)
			{
				dtCandidateNode candidate2;
				candidate2.index = node.child2;
				candidate2.inheritanceCost = inheritanceCost;
				m_heap.push_back(candidate2);
				std::push_heap(m_heap.begin(), m_heap.end());
			}
		}
	}

	m_maxHeapCount = dtMax(m_maxHeapCount, int(m_heap.size()));

#### trick

##### 松散AABB

物体移动的时候，如果是点击拖动再释放，仅调用一次move的话，不用考虑松散AABB；

如果是拖拽中，调用多次move的话，可以增加一层松散AABB，如果某一帧的改变后，窄AABB不超过其松散AABB，当前帧仅更新窄AABB即可
![image-20221021182310237.png](https://images-1318884142.cos.ap-guangzhou.myqcloud.com/images/202306232123216.png)


##### **AABB的快速从模型坐标系还原到世界坐标系中**

常规方法：

原始Box的Pmax、Pmin经过变换后，并不一定仍在是这两个顶点，需要将Box的8个顶点都进行变换，再对这8个顶点进行比较

快速解法：

center = (Pmax+Pmin)/2

r = (Pmax-Pmin)/2

8个顶点为 center+-r的组合变换 2(xmin、xmax) * 2(ymin、ymax)* 2(zmin、zmax)

![image-20221020162609934.png](https://images-1318884142.cos.ap-guangzhou.myqcloud.com/images/202306232123746.png)

变换后的8个顶点的齐次形式如下：

![image-20221020162620791.png](https://images-1318884142.cos.ap-guangzhou.myqcloud.com/images/202306232123301.png)

变换后的Box的Pmin、Pmax:

![image-20221020162734203.png](https://images-1318884142.cos.ap-guangzhou.myqcloud.com/images/202306232123188.png)

M*（x,y,z,1）可以拆分为4个列向量相加：M0 * x + M1 * y + M2 * z + M3 * 1

并且min(A+B) = minA + minB，下面的做法减少了计算量，增加了计算数据的复用性

加速后：6次列向量*标量，6次max/min向量，8次向量加法 >8个顶点的旋转平移+8个顶点的min/max

    Vector3f a1 = m_row0 * pMin.x;	//M0*x
    Vector3f a2 = m_row0 * pMax.x;

    Vector3f b1 = m_row1 * pMin.y;
    Vector3f b2 = m_row1 * pMax.y;

    Vector3f c1 = m_row2 * b.pMin.z;
    Vector3f c2 = m_row2 * b.pMax.z;
    float w = m[3][3];
    Vector3f pmin_  =  Min(a1,a2) + Min(b1,b2) + Min(c1,c2) + m_row3;// Min(vec3,vec3):新的向量的x=min(a1.x,a2.x).....
    Vector3f pmax_  =  Max(a1,a2) + Max(b1,b2) + Max(c1,c2) + m_row3;
    box.pMin = {pmin_.x/w,pmin_.y/w,pmin_.z/w};	//标准化齐次坐标。x,y,z,w	-> x',y',z',1
    box.pMax = {pmax_.x/w,pmax_.y/w,pmax_.z/w};
    return box;

参考：pbrt

##### 伪动态BVH

单独维护一个buffer，对于变动的node都放到池子中，并维护一个静态BVH

优先在静态BVH中 查找，之后遍历池子，进行查找

如果池子中的node到达一定数量，清空，并重新构建一个静态BVH

构建性能最佳，搜索效率最低

#### 踩坑

目前流程中的remove节点，仅考虑到局部的cost，其实其对全局的cost应该会有影响

因此，remove会存在误差累积，当误差累积到一定程度，需要进行re-build

数量级少，通过insert来重构SAH最优的树，数量级大时，基于LVBH进行重构，树的质量较低，但是不存在误差累积

tip：

①可参考的论文中，没有对remove做特殊处理，是对其作了取舍的【box2d、Fast Insertion-Based Optimization of Bounding Volume Hierarchies】

②单个节点的insert，生成树的质量最高；基于SAH的实际生成，根据桶的划分，其质量有所下降；LVBH的并行构建子树也会额外引入质量降低

③remove的全局影响，是否需要考虑？ 可参考树的优化过程

#### 参考文献

Box2D算法说明:[Box2D：算法说明](https://box2d.org/files/ErinCatto_DynamicBVH_Full.pdf)

Box2D配套代码，有多个实现版本：[dynamic-tree/tree.cpp at master · erincatto/dynamic-tree · GitHub](https://github.com/erincatto/dynamic-tree/blob/master/src/tree.cpp)

Box2D的中文博客：旧版本，有出入，仅辅助参考[(77条消息) Box2d源码学习<六>动态树的实现_扭曲45的博客-CSDN博客](https://blog.csdn.net/cg0206/article/details/8293049)

①动态更新

insert & buffer

insert的查找效率较高，始终是一棵树

②build

SAH & insert

③多线程build

Q1:验证当存在大场景包围cd

## 3月

### imgui

#### demo++

#### 鼠标交互事件

左键单击、右建单击、鼠标释放、左键拖动、右键拖动、shift+左键拖动事件如下：

左击时间
右击时间

//伪代码
fn event(){
	if 左击{
		if 按下shift{
			记录第一次shift的坐标
		}
		
		if 第一次shift坐标存在{
			shift_event()
		}else{
			if 第一次左击{
			记录左击时间
			}
			if now-左击时间 > 阈值{
			left_drag_event()
			}
		}
	}
	
	if 右击{
		if 第一次右击{
			记录右击时间
		}
		if now-右击时间 > 阈值{
			right_drag_event()
		}
	}
	
	if 鼠标释放{
		if 左击过 && now-左击时间<阈值{
			left_press_event()
		}
		if 右击过 && now-右击时间<阈值{
			right_press_event()
		}
		
		release_event()
	}
	
	if 滑轮滚动{
		wheel_event(move:f32)
	}
}

### 对象池

内存池：先申请一块内存，后续增加的geometry、matrial写入这块内存中，减少内存申请

难点：为什么能优化性能，rust如何申请动态内存

#### WHY

减少动态内存分配（堆申请），降低内存碎片化，提高内存访问效率，提高内存分配效率

#### WHAT

##### 堆栈：

1.内存

栈的内存是向低地址扩展数据解构，是一块**连续内存**；

栈顶的地址和最大容量是系统预定好的，一般为2M或1M，可用空间较少

堆的内存是向高地址拓展数据结构，是**非连续内存**；

系统通过链表来存储空间内存地址，堆区的内存就由这些不连续的内存块组成，可用空间较大，但不连续

2.申请内存

栈的内存申请较快，如果申请空间超过可用内存，溢出报错；否则，直接压栈

堆区的内存申请需要根据申请的内存大小，去遍历空余内存地址链表，找到第一块可以存放的内存块，将剩余内存重新存放回链表中（ps:内存碎片的产生）
![image-20230313141554124.png](https://images-1318884142.cos.ap-guangzhou.myqcloud.com/images/202306232125149.png)


3.数据访问

堆区的数据访问效率 < 栈

4.内存碎片

内存碎片的两种形式：

内部碎片，由字节对齐导致；

外部碎片，由堆区内存申请导致

内存碎片会降低内存空间使用率，将空间变得碎片
![image-20230313101537052.png](https://images-1318884142.cos.ap-guangzhou.myqcloud.com/images/202306232125635.png)

5.memory diffusion

在不断的插入、删除操作后，导致遍历元素时，地址不连续，指针跳转频繁，随机读取内存！这破坏了访问时序上的连续性

①对象池的本质在于对象内容大小不变，并且可重复复用

②内存池的本质在于提前申请内存，将相似内容存入到内存池中，减少频繁申请内存的开销

③geometry麻烦点在于，顶点数量不固定，可以将顶点单独存放在堆区

#### HOW

#### 参考文献

[对象池模式 · Optimization Patterns · 游戏设计模式 (tkchu.me)](https://gpp.tkchu.me/object-pool.html)

ps:对象池会减少部分内存申请的开销，很难完全减少

## 4月

### FFI

#### 概述

FFI：跨语言调研的机制，根本原因：编程语言都是二进制，考虑到通用性，通常都是对外**暴露C接口**

#### 语法

#[no_mangle]
pub unsafe extern "C" fn function() -> bool{
	
}

##### #[no_mangle]

用来声明，禁用name_mangling[Name mangling - Wikipedia](https://en.wikipedia.org/wiki/Name_mangling)，使得对外导出的是预期的函数名，而不是_ZN7battery_get_percentage17h5179a29d7b114f74E

##### unsafe

标记unsafe

##### extern "C"

函数调用遵循C约定[Calling convention - Wikipedia](https://en.wikipedia.org/wiki/Calling_convention)

#### 数据传递

##### 基础类型

Rust [std](https://link.zhihu.com/?target=https%3A//doc.rust-lang.org/std/index.html)::[ffi](https://link.zhihu.com/?target=https%3A//doc.rust-lang.org/std/ffi/) & The libc crate：包含Rust 和 C的基础类型交集，f32->float....

##### 结构体/枚举

通过#[repr(C)]，保证相同的内存布局

##### raw pointer

对rust的数据，传递裸指针（* const T, * mut T）

通过裸指针，绕过Rust的借用规则、不会被自动回收、不能保证指向内存的合法性

传出裸指针：Rust to C

//address
let address = 0x012345usize;
let r = address as *const i32;

//as
let mut num = 5;
let r1 = &num as *const i32;
let r2 = &mut num as *mut i32;

//Box::into_raw
let ptr = Box:into_raw(Box::new(5))

接收裸指针:C to Rust

//unsafe
let p:&T = &(*ptr)

//Box::form_raw
let b:Box< T > = Box::from_raw(ptr)

释放裸指针内存:

裸指针转Box< T >，函数结束时，自动drop Box< T >；或手动drop：仅仅起强调作用

##### 连续内存

传递ptr和len，外面读取完数据再调用Rust释放数据

 ptr:*const T
 len:usize

对于复杂结构体的数组，与上述相同，区别是C端拿到地址后，按照结构体的形式解析

#### 第三方库

#### cbindgen

对Rust库（已经extern C接口）生成C/C++头文件，对C的支持性更好

##### install

cargo install --force cbindgen

##### cbindgen.toml配置

[cbindgen/template.toml at master · eqrion/cbindgen (github.com)](https://github.com/eqrion/cbindgen/blob/master/template.toml)

##### 变量配置

可以为struct、enum添加注释，自动派生方法或命名匿名字段

/// cbindgen:field-names=[x, y]
/// cbindgen:derive-eq

##### run

//cmd
cbindgen --config cbindgen.toml --crate my_rust_library --output my_header.h

//build.rs
extern crate cbindgen;
use std::env;

fn main() {
    let crate_dir = env::var("CARGO_MANIFEST_DIR").unwrap();

    cbindgen::Builder::new()
      .with_crate(crate_dir)
      .generate()
      .expect("Unable to generate bindings")
      .write_to_file("bindings.h");
}

cbindgen会扫描rust库中extern C的接口，并对相关参数也进行导出，如果有的参数需要但是没暴露，需要在cbindgen.toml单独配置

build.rs的方式会在编译create之前，先编译执行build.rs的代码

[Rust FFI 实践 - 简书 (jianshu.com)](https://www.jianshu.com/p/f76631edbbfd)

[Rust FFI 编程 - FFI 概述 - Rust语言中文社区 (rustcc.cn)](https://rustcc.cn/article?id=3b8241d0-c4ca-4f49-8e07-0a5142b00f59)

[Rust FFI 编程 - cbindgen 工具介绍 - Rust语言中文社区 (rustcc.cn)](https://rustcc.cn/article?id=a77aedb2-44f6-48aa-a032-954c87867068)

[cbindgen/docs.md at master · eqrion/cbindgen (github.com)](https://github.com/eqrion/cbindgen/blob/master/docs.md)

### 三点定圆 快速解法

常规思路：3点带入，摩拉默法则求解

快速思路：参考曲线系方程，曲线系代表一系列方程，这些方程具有共性，根据这个共性定义曲线方程

**ex:过直线L1和直线L2角点的直线系方程 F = F1 + alpha * F2**

过直线L1和圆R1的两个交点的圆系方程 **F = R1 + alpha * L1**

三点定圆：先取两点**AB**定义圆系方程，再带入第三点**C**，求出alpha，定义圆的方程

以AB为直径的圆方程 （x-x1)(x-x2) + (y-y1)(y-y2)=0 ：圆上任意一点P，必有PA*PB=0

过AB的直线方程 （x-x1）(y2-y1) - (y-y1)(x2-x1)=0: k = y2-y1/x2-x1, y - y1= k* x -x1

**alpha = - F1/F2，当F2（C）=0，说明。ABC三点共线，圆退化为直线**

是否不用硬解？？？解出圆的一般方程: x * x + y * y +[ alpha (y2-y1) - (x1+x2) ] * x + [alpha(x1-x2) - (y1+y2)] * y + alpha * (x2*y1 +-x1 * y2) + x1*x2+ y1 * y2

x*x + y * y + a*x + b * y +c =0

a =alpha(y2-y1)-(x1+x2)

b =alpha(x1-x2) - (y1+y2)

c = alpha * (x2*y1 - x1 * y2) + x1*x2+ y1 * y2

center(-a/2, -b/2)

radius(a * a /4 + b * b /4 - c)开根号

圆系方程动图：[曲线系方程教程 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/103876294)

[【解析几何】曲线系方程 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/137229143)

## 5月

### distance of point to triangle

**Interior to Edge**:假定point优先落在三角形内部，具体不表

**Edge to Interior**:假定point优先落在三角形外部，并且极大概率最近点就是三角形的顶点

#### 踩坑

##### Edge to Interior
![image-20230506171406732.png](https://images-1318884142.cos.ap-guangzhou.myqcloud.com/images/202306232127220.png)


Triangle Vertices:V0, V1, V2

Triangle Edge: E0(V1-V0), E1(V2-V1), E2(V0-V2)

假设P=V0 + t0*(V1-V0) + t1 *(V2-V0)，则P的分布情况如上图所示

其中如果P落入V0区域，则最近点必为顶点V0，V1, V2区域同理: v0（t0 = 0, t1 = 0）,V1(t0 =1, t0=0)、V2(t0=0, t1=1)

如果P落入E0区域，则最近点落在边E0，其他同理：E0（t1=0, 0<t2<1），此时直接计算重心坐标

否则，落入T区域，最近点位于三角形内部，distance=0

**伪代码**

**先计算 n0,n1,n2探索顶点是否为最近点，后续再复用n0,n1,n2，计算重心坐标，判断在某条边上， 还是落入三角形内部**

float SquaredDistance (Point P, Triangle T)
{
// triangle vertices V0, V1, V2, edges E0=<V0, V1>, E1=<V2, V1>, E2=<V0, V2>

//check triangle downgrade line

// closest point is vertex
	float n0 = (P-V0)Dot(V1-V0);
	float n1 = (P-V0)Dot(V2-V0);
	if (n0 <= 0 & n1 <= 0) // closest point is vertex V0
		return V0
		
	float n2 = (P-V1)Dot(V2-V1);
	if (n0 >= 1 & n2 <= 0) // closest point is vertex V1
		return V1
	if (n1 >= 1 & n2 >= 1) // closest point is vertex V2
		return V2

// closest point is in edge
//计算P的重心坐标
	// Compute vectors        
	v0 = C - A
	v1 = B - A
	v2 = P - A

    // Compute dot products
    dot00 = dot(v0, v0)
    dot01 = dot(v0, v1)
    dot02 = dot(v0, v2)
    dot11 = dot(v1, v1)
    dot12 = dot(v1, v2)

    // Compute barycentric coordinates
    invDenom = 1 / (dot00 * dot11 - dot01 * dot01)
    u = (dot11 * dot02 - dot01 * dot12) * invDenom
    v = (dot00 * dot12 - dot01 * dot02) * invDenom
	
	if (u < 0) // closest point on edge E0
		return SquaredLength(Y - (V1 + t1 * (V2 - V1)));
	if (v < 0) // closest point is on edge E1
		return SquaredLength(Y - (V2 + t2 * (V0 - V2)));
	if ( 1-u-v < 0) // closest point is on edge E2
		return SquaredLength(Y - (V0 + t0 * (V1 - V0)));

// closest point is in triangle
	return 0; // P is inside triangle
}

##### 重心坐标计算

推导过程

P = V0+ u* (V1-V0) + v * (V2-V0)
P-V0 = u* (V1-V0) + v * (V2-V0)

D0 = P-V0, D1 = V1-V0, D2 = V2-V0
D0 = u* D1 + v* D2

D0 * D1 = u * D1 *D1 + v * D2 * D1
D0 * D2 = u * D1 *D2 + v * D2 * D2

u= ...
v=...

代码

// Compute vectors        
v0 = C - A
v1 = B - A
v2 = P - A

// Compute dot products
dot00 = dot(v0, v0)
dot01 = dot(v0, v1)
dot02 = dot(v0, v2)
dot11 = dot(v1, v1)
dot12 = dot(v1, v2)

// Compute barycentric coordinates
invDenom = 1 / (dot00 * dot11 - dot01 * dot01)
u = (dot11 * dot02 - dot01 * dot12) * invDenom
v = (dot00 * dot12 - dot01 * dot02) * invDenom

// Check if point is in triangle
return (u >= 0) && (v >= 0) && (u + v < 1)

#### 正确思路

[tlpHX.png (1230×1183) (imgur.com)](https://i.stack.imgur.com/tlpHX.png)

上述方法对于钝角三角形，会有错解，最近点为顶点时，没有问题；但是判断最近点落在边上时，会有错误，不能用重心坐标来判断，改用SAT来判断点P和V2是否落在Edeg:V0V1的两侧，并且在V0V1上的投影>0 & < len

let edge0=V1-V0;

快速求法线 Normal = (-edge0.y,edge0.x); //无需区分内外侧，只检测P V2落在两侧即可，所以此处的normal不需要区分朝向

if (P-V0) . dot （edge0) * (V2-V0).dot (dege0) <0{ //P V2落在V0V1两侧，加上之前判断最近点不在顶点上，即可说明此时最近点在边V0V1上
![image-20230531103949402.png](https://images-1318884142.cos.ap-guangzhou.myqcloud.com/images/202306232128692.png)

}

float find_closest (Point P, Triangle T)
{
// triangle vertices V0, V1, V2, edges E0=<V0, V1>, E1=<V2, V1>, E2=<V0, V2>

//check triangle downgrade line
let value = (x2-x0)*(y1-y0) - (y2-y0)*(x1-x0);
if vaule <0 {
	let mut line = triangle;
	if (v0-v1).length2 =0{
		line[1] = primitive[2] //line v0,v2
	}
	LineSegment::find_closest(line,point)//line v0,v1
}

// closest point is vertex
float n0 = (P-V0)Dot(V1-V0);
float n1 = (P-V1)Dot(V2-V1);
let len0=(V1-V0)Dot(V1-V0);
if (n0 >= len0 & n1 <= 0) // closest point is vertex V1
return V1
		
float n2 = (P-V2)Dot(V0-V2);
let len1= (V2-V1)Dot(V2-V1);
if (n1 >= 1en1 & n2 <= 0) // closest point is vertex V2
	return V2
let len2 = (V0-V2)Dot(V0-V2);
if (n2 >= 1en2 & n0 <= 0) // closest point is vertex V0
	return V0

// closest point is in edge by SAT
let normal0 =vec2(-e0.y,e0.x);
if normal0.Dot(P-V0) * normal0.Dot(V2-V0)<0 & n0 >0 & n0 < len0{
	//closest point in V0,V1
	return V0 + n0/len0 * e0;
}
let normal1 =vec2(-e1.y,e1.x);
if normal1.Dot(P-V1) * normal1.Dot(V0-V1)<0 & n1 >0 & n1 < len1{
	//closest point in V1,V2
	return V1 + n1/len1 * e1;
}
let normal2 =vec2(-e2.y,e2.x);
if normal2.Dot(P-V2) * normal2.Dot(V1-V2)<0 & n2 >0 & n2 < len2{
	//closest point in V2,V0
	return V2 + n2/len2 * e2;
}

// closest point is in triangle
	return point; // P is inside triangle
}

#### 参考

Geometric Tools for Computer Graphics PDF：6.2 Distance point to triangle**（错解，没有考虑到钝角三角形）**

[计算重心坐标](https://blackpawn.com/texts/pointinpoly/default.html)